////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////																////
////		    This ImageJ macro plots a kriging estimation of growth from raw PointTracker data		////
////					   by calling the javascript 'Plot_Kriging.js'.						////
////																////
////							Florent Pantin, 2013							////
////																////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/// Initial settings

	// Set file separators
	lineseparator = "\n";
	cellseparator = ",";

	// Set the path of R and scripts
	pathOfScripts = getDirectory("imagej") + "macros\\Track 'n' R\\";
	pathOfScripts = replace(pathOfScripts, "PROGRA~1", "Program Files");
	pathOfScripts = replace(pathOfScripts, "PROGRA~2", "Program Files (x86)");
	nameOfScript = "Plot_Kriging";
	nameOfRScript = nameOfScript + ".r";
	nameOfRoutFile = nameOfRScript + ".Rout";
	nameOfJavaScript = nameOfScript + ".js";
	while (File.exists(pathOfScripts + "Track_n_R.r") != 1 || File.exists(pathOfScripts + nameOfRScript) != 1 || File.exists(pathOfScripts + nameOfJavaScript) != 1)
		{
		Dialog.create("Error");
		Dialog.addMessage("The scripts:\n    - Track_n_R.r\n    - " + nameOfRScript + "\n    - " + nameOfJavaScript + "\nare not all present in the expected folder (" + pathOfScripts + ").\nSelect the directory where the three of them are located.");
		Dialog.show();
		pathOfScripts = getDirectory("Select the script directory");
		}
	if (File.exists(pathOfScripts + "Rpath.txt") !=1)
		{
		Rpath = "";
		while (endsWith(Rpath, "\\R.exe") != 1)
			{
			Rpath = File.openDialog("Select the R executable (e.g. 'C:\\Program Files\\R\\R-3.0.1\\bin\\x64\\R.exe')");
			}
		f = File.open(pathOfScripts + "Rpath.txt");
		print(f, Rpath);
		File.close(f);
		}
	else
		{
		Rpath = split(File.openAsString(pathOfScripts + "Rpath.txt"), lineseparator);
		Rpath = split(Rpath[0], cellseparator);
		Rpath = Rpath[0];
		if (File.exists(Rpath) !=1)
			{
			Rpath = "";
			while (endsWith(Rpath, "\\R.exe") != 1)
				{
				Rpath = File.openDialog("Select the R executable (e.g. 'C:\\Program Files\\R\\R-3.0.1\\bin\\x64\\R.exe')");
				}
			f = File.open(pathOfScripts + "Rpath.txt");
			print(f, Rpath);
			File.close(f);
			}
		}
	
	// Set the csv file and the directory containing the project
	csvFile = File.openDialog("Select the csv file containing raw data");
	csvName = File.getName(csvFile);
	csvPath = substring(csvFile, 0, indexOf(csvFile, csvName));
	idx_Data = indexOf(csvPath, "Data\\");
	if (idx_Data != -1) { projDir = substring(csvFile, 0, idx_Data); } else { projDir = "error"; };
	while ((endsWith(csvFile, ".csv") != 1) || (projDir + "Data\\" + csvName != csvFile))
		{
		Dialog.create("Error");
		Dialog.addMessage("The file should be a CSV file located in the 'Data\' folder of the project directory.\nSelect the csv file again.");
		Dialog.show();
		csvFile = File.openDialog("Select the csv file containing raw data");
		csvName = File.getName(csvFile);
		csvPath = substring(csvFile, 0, indexOf(csvFile, csvName));
		idx_Data = indexOf(csvPath, "Data\\");
		if (idx_Data != -1) { projDir = substring(csvFile, 0, idx_Data); }	else { projDir = "error"; };
		}


/// Get images to be plotted

	// Get the image information

	linesInfo = split(File.openAsString(csvFile), lineseparator);
	Names = split(linesInfo[1], cellseparator);
	XYshift = split(linesInfo[2], cellseparator);
	AngleShiftTime = split(linesInfo[3], cellseparator);
	Scales = split(linesInfo[4], cellseparator);

	// edit 2018/08/25 //
	// In some systems, empty cells are not ignored when a line is imported, while in others they are.
	// This is a problem because two consecutive image names are always separated by an empty cell in PointTracker files.
	// This piece of code allows removing the empty names.
	if (Names.length == XYshift.length)
		{
		NamesTemp = Array.trim(Names, 1);
		for (i = 1; i < (Names.length-1)/2+1; i++) 
			{
			NamesTemp = Array.concat(NamesTemp, Array.slice(Names, (i*2)-1, i*2)); 
			}
		Names = NamesTemp;
		}
	// end edit //


	// Build the checkbox list

	nrow = minOf(16, Names.length - 1); // maximum 16 rows
	ncol = -floor(-(Names.length - 1)/nrow);
	n = nrow*ncol;
	labels = newArray(n);
	defaults = newArray(n);
	i = 0;
	for (c = 0; c < ncol; c++)
		{
		for (r = 0; r < nrow; r++)
			{
			j = r*ncol + c;
			defaults[j] = false;
			if (i < (Names.length - 1))
				{
				name = Names[1 + i];
				time = parseFloat(AngleShiftTime[1+ (2*i) +1]);
				labels[j] = name + " (" + round(10*time)/10 + " h)";
				}
			else
				{
				labels[j] = "(empty, do not tick)";
				}
			i = i + 1;
			}
		}	


	// Ask user for the list of images and save

	check_Images = "FALSE";
	while (check_Images == "FALSE")
		{
		// Delete putative old file (just in case it was not deleted properly before)
		File.delete("D:\\ImageList.txt");		
		
		// Open the dialog box for choice of the images
		Dialog.create("Select images for kriging");
		Dialog.addMessage("Select at least two images between which kriging estimation of growth will be plotted.");
		Dialog.addCheckbox("Use all images", false);
		Dialog.addMessage(" \n");
		Dialog.addCheckboxGroup(nrow, ncol, labels, defaults);
		Dialog.show();

		// Get the images back
		allImages = Dialog.getCheckbox();
		if (allImages == 1)
			{
			f = File.open("D:\\ImageList.txt");
			for (i = 0; i < (Names.length - 1); i++)
				{
				print(f, Names[1 + i]);
				}
			File.close(f);
			check_Images = "TRUE";
			}
		else
			{
			countImages = 0;
			isIncluded = newArray(Names.length - 1);
			for (j = 0; j < n; j++)
				{
				img = Dialog.getCheckbox();
				i = floor(nrow*j/n) + nrow*(j - ncol * floor(nrow*j/n));
				if (img == 1 && i < (Names.length - 1))
					{
					isIncluded[i] = 1;
					countImages = countImages + 1;
					}
				else if (img == 0 && i < (Names.length - 1))
					{
					isIncluded[i] = 0;
					}
				}
			if (countImages >= 2)
				{
				f = File.open("D:\\ImageList.txt");
				for (i = 0; i < (Names.length - 1); i++)
					{
					if (isIncluded[i] == 1)
						{
						print(f, Names[1 + i]);
						}
					}
				File.close(f);
				check_Images = "TRUE";
				}
			else
				{
				Dialog.create("Error");
				Dialog.addMessage("At least two images need to be ticked. Select the images again.");
				Dialog.show();
				}
			}
		}


/// Get parameters

	// Open the dialog box of the parameters

	BooleanOrMissing = newArray("Let the software decide", "Yes", "No");
	Dialog.create("Choose parameters");
	
	Dialog.setInsets(0, 0, 0);
	Dialog.addMessage("#####################################  GENERAL  #####################################");
	Dialog.addString("Scale bar in microns (keep BLANK to ignore scale bar):","");	
	Dialog.setInsets(0, 20, 0);
	Dialog.addCheckboxGroup(1, 3, newArray("Plot on end image", "Black background", "Draw ticks for scale bar (if any)"), newArray(true, true, false));
	Dialog.addCheckbox("Fit all images to the dimensions of the last image (Y-axis limits below will be ignored)", false);
	Dialog.addString("Enter minimum for the Y-axis (in microns, possibly negative) (keep BLANK if unknown):", "");
	Dialog.addString("AND maximum for the Y-axis (in microns) (keep BLANK if unknown):", "");
	
	Dialog.addRadioButtonGroup("Use leaf outline", BooleanOrMissing, 1, 3, "Let the software decide");
	Dialog.addCheckbox("Align to petiole-lamina boundary", true);
	Dialog.addString("Cell # at petiole-lamina boundary (keep BLANK if lowest tracked cell):","");
	Dialog.addString("Mean angle (°) the leaf should be rotated to be vertical (keep BLANK if drawn leaf outlines):","");

	Dialog.setInsets(0, 0, -10);
	Dialog.addMessage("#####################################   GROWTH   #####################################");
	Dialog.addRadioButtonGroup("Use %/h", BooleanOrMissing, 1, 3, "Let the software decide");
	//Dialog.addRadioButtonGroup("Colour palette", newArray("GFtbox", "Blue to red"), 1, 2, "GFtbox");
	Dialog.addChoice("Growth variable:", newArray("karea", "kmaj", "kmin", "theta", "phi", "anisotropy", "kpertoml", "kml"));
	//Dialog.addChoice("Growth variable:", newArray("karea", "kmaj", "kmin", "theta", "phi", "anisotropy", "kpertoml", "kml", "area")); // Not used to avoid confusion, but R will accept it
	Dialog.addString("Enter minimum for growth (keep BLANK if unknown):", "");
	Dialog.addString("AND maximum for growth (keep BLANK if unknown):", "");
	Dialog.addCheckbox("Use rounded limits (ignored if mini and maxi provided)", true);
	Dialog.addCheckbox("Set growth to colour of minimum when below minimum (if unticked: transparent)", true);
	Dialog.addCheckbox("Set growth to colour of maximum when above maximum (if unticked: transparent)", true);
	Dialog.addCheckbox("Show growth scale", true);
	Dialog.addCheckbox("Show intermediate ticks on the growth scale", true);
	Dialog.addString("Text for the growth scale (keep BLANK to let the software decide):","");

	Dialog.setInsets(0, 0, -10);
	Dialog.addMessage("####################################  ANISOTROPY  ####################################");
	Dialog.addRadioButtonGroup("Show anisotropy", BooleanOrMissing, 1, 3, "Let the software decide");
	Dialog.addNumber("Anisotropy threshold (0 - 1):", 0.05);
	Dialog.addString("Positive factor for thickness of anisotropy lines (keep BLANK to let the software decide):","");
	Dialog.addCheckbox("Constant thickness for anisotropy lines", false);
	
	Dialog.show();


	// Get the values back and transform them to match R script's requirements

	error_scaleBar = "FALSE";
	error_ylim = "FALSE";
	check_ymini = "FALSE";
	check_ymaxi = "FALSE";
	error_cellAtPetioleLaminaBoundary = "FALSE";
	error_meanAngle = "FALSE";
	error_zlim = "FALSE";
	check_zmini = "FALSE";
	check_zmaxi = "FALSE";
	error_anisothreshold = "FALSE";
	error_anisolwd = "FALSE"; 

	scaleBar = Dialog.getString();
	if (replace(scaleBar, " ", "") == "") { scaleBar = "NULL"; }; else { scaleBar = parseFloat(scaleBar); if (isNaN(scaleBar)) { error_scaleBar = "TRUE"; }; };
	after = Dialog.getCheckbox();
	if (after == 0) { before = "TRUE"; }; else { before = "FALSE"; };
	black = Dialog.getCheckbox();
	if (black == 1) { black = "TRUE"; }; else { black = "FALSE"; };
	tick = Dialog.getCheckbox();
	if (tick == 1) { tick = "TRUE"; }; else { tick = "FALSE"; };
	fitLast = Dialog.getCheckbox();
	if (fitLast == 1) { fitLast = "TRUE"; }; else { fitLast = "FALSE"; };
	ymini = Dialog.getString();
	if (replace(ymini, " ", "") == "") { ymini = "NULL"; check_ymini = "TRUE"; }; else { ymini = parseFloat(ymini); if (isNaN(ymini)) { error_ylim = "TRUE"; }; };
	ymaxi = Dialog.getString();
	if (replace(ymaxi, " ", "") == "") { ymaxi = "NULL"; check_ymaxi = "TRUE"; }; else { ymaxi = parseFloat(ymaxi); if (isNaN(ymaxi)) { error_ylim = "TRUE"; }; };
	if (check_ymini != check_ymaxi) { error_ylim = "TRUE"; };
	if (fitLast == "TRUE") { ymini = "NULL";  ymaxi = "NULL"; error_ylim = "FALSE"; };

	leafShape = Dialog.getRadioButton();
	if (leafShape == "Let the software decide") { leafShape = "NULL"; } else if (leafShape == "Yes") { leafShape = "TRUE"; } else if (leafShape == "No") { leafShape = "FALSE"; };
	alignToPetioleLaminaBoundary = Dialog.getCheckbox();
	if (alignToPetioleLaminaBoundary == 1) { alignToPetioleLaminaBoundary = "TRUE"; }; else { alignToPetioleLaminaBoundary = "FALSE"; };
	cellAtPetioleLaminaBoundary = Dialog.getString();
	if (replace(cellAtPetioleLaminaBoundary, " ", "") == "") { cellAtPetioleLaminaBoundary = "NULL"; }; else { cellAtPetioleLaminaBoundary = parseFloat(cellAtPetioleLaminaBoundary); if (isNaN(cellAtPetioleLaminaBoundary)) { error_cellAtPetioleLaminaBoundary = "TRUE"; }; else if (cellAtPetioleLaminaBoundary != round(cellAtPetioleLaminaBoundary)) { error_cellAtPetioleLaminaBoundary = "TRUE"; }; };			
	meanAngle = Dialog.getString();
	if (replace(meanAngle, " ", "") == "") { meanAngle = "NULL"; }; else { meanAngle = parseFloat(meanAngle); if (isNaN(meanAngle)) { error_meanAngle = "TRUE"; }; };

	Percent = Dialog.getRadioButton();
	if (Percent == "Let the software decide") { Percent = "NULL"; } else if (Percent == "Yes") { Percent = "TRUE"; } else if (Percent == "No") { Percent = "FALSE"; };
	Palette = "GFtbox"; //Palette = Dialog.getRadioButton();
	if (Palette == "GFtbox") { colorPaletteOfGFtbox = "TRUE"; } else { colorPaletteOfGFtbox = "FALSE"; };
	kgrowth = Dialog.getChoice();
	if (kgrowth == "karea") { kgrowth = 2; }
	else if (kgrowth == "kmaj") { kgrowth = 3; }
	else if (kgrowth == "kmin") { kgrowth = 4; }
	else if (kgrowth == "theta") { kgrowth = 5; }
	else if (kgrowth == "phi") { kgrowth = 6; }
	else if (kgrowth == "anisotropy") { kgrowth = 7; }
	else if (kgrowth == "kpertoml") { kgrowth = 8; }
	else if (kgrowth == "kml") { kgrowth = 9; }
	else { if (before == "TRUE") { kgrowth = 10; } else { kgrowth = 11; }; };
	zmini = Dialog.getString();
	if (replace(zmini, " ", "") == "") { zmini = "NULL"; check_zmini = "TRUE"; }; else { zmini = parseFloat(zmini); if (isNaN(zmini)) { error_zlim = "TRUE"; }; };
	zmaxi = Dialog.getString();
	if (replace(zmaxi, " ", "") == "") { zmaxi = "NULL"; check_zmaxi = "TRUE"; }; else { zmaxi = parseFloat(zmaxi); if (isNaN(zmaxi)) { error_zlim = "TRUE"; }; };
	if (check_zmini != check_zmaxi) { error_zlim = "TRUE"; };
	roundzlim = Dialog.getCheckbox();
	if (roundzlim == 1) { roundzlim = "TRUE"; }; else { roundzlim = "FALSE"; };
	fixmin = Dialog.getCheckbox();
	if (fixmin == 1) { fixmin = "TRUE"; }; else { fixmin = "FALSE"; };
	fixmax = Dialog.getCheckbox(); 
	if (fixmax == 1) { fixmax = "TRUE"; }; else { fixmax = "FALSE"; };
	growthScale = Dialog.getCheckbox();
	if (growthScale == 1) { growthScale = "TRUE"; }; else { growthScale = "FALSE"; };
	drawTicks = Dialog.getCheckbox();
	if (drawTicks == 1) { drawTicks = "TRUE"; }; else { drawTicks = "FALSE"; };
	txtlegend = Dialog.getString();
	if (replace(txtlegend, " ", "") == "") { txtlegend = "NULL"; };

	anisotropy = Dialog.getRadioButton();
	if (anisotropy == "Let the software decide") { anisotropy = "NULL"; } else if (anisotropy == "Yes") { anisotropy = "TRUE"; } else if (anisotropy == "No") { anisotropy = "FALSE"; };
	anisothreshold = Dialog.getNumber();
	if (anisothreshold != parseFloat(anisothreshold)) { error_anisothreshold = "TRUE"; };
	else if (anisothreshold < 0 || anisothreshold > 1) { error_anisothreshold = "TRUE"; };
	anisolwd = Dialog.getString();
	if (replace(anisolwd, " ", "") == "") { anisolwd = "NULL"; }; else { anisolwd = parseFloat(anisolwd); if (isNaN(anisolwd)) { error_anisolwd = "TRUE"; }; };
	anisolwdconstant = Dialog.getCheckbox();
	if (anisolwdconstant == 1) { anisolwdconstant = "TRUE"; }; else { anisolwdconstant = "FALSE"; };


	// Check potential errors

	while (error_scaleBar == "TRUE")
		{
		error_scaleBar = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("The scale bar should be either missing or given as a numeric values in microns.");
		Dialog.addString("Scale bar in microns (keep BLANK to ignore scale bar):","");
		Dialog.show();
		scaleBar = Dialog.getString();
		if (replace(scaleBar, " ", "") == "") { scaleBar = "NULL"; }; else { scaleBar = parseFloat(scaleBar); if (isNaN(scaleBar)) { error_scaleBar = "TRUE"; }; };
		}

	while (error_ylim == "TRUE")
		{
		error_ylim = "FALSE";
		check_ymini = "FALSE";
		check_ymaxi = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("The limits for the Y-axis should be either missing or given as two numeric values.");
		Dialog.addString("Enter minimum for the Y-axis (in microns, possibly negative) (keep BLANK if unknown):", "");
		Dialog.addString("AND maximum for the Y-axis (in microns) (keep BLANK if unknown):", "");
		Dialog.show();
		ymini = Dialog.getString();
		if (replace(ymini, " ", "") == "") { ymini = "NULL"; check_ymini = "TRUE"; }; else { ymini = parseFloat(ymini); if (isNaN(ymini)) { error_ylim = "TRUE"; }; };
		ymaxi = Dialog.getString();
		if (replace(ymaxi, " ", "") == "") { ymaxi = "NULL"; check_ymaxi = "TRUE"; }; else { ymaxi = parseFloat(ymaxi); if (isNaN(ymaxi)) { error_ylim = "TRUE"; }; };
		if (check_ymini != check_ymaxi) { error_ylim = "TRUE"; };
		}
	if (ymini == parseFloat(ymini)) { if (ymini > ymaxi) { ymini_temp = ymini; ymini = ymaxi; ymaxi = ymini_temp; }; };

	while (error_cellAtPetioleLaminaBoundary == "TRUE")
		{
		error_cellAtPetioleLaminaBoundary = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("The cell at the petiole-lamina boundary should be either missing or given as an integer corresponding to an existing cell.");
		Dialog.addString("Cell # at petiole-lamina boundary (keep BLANK if lowest tracked cell):","");
		Dialog.show();
		cellAtPetioleLaminaBoundary = Dialog.getString();
		if (replace(cellAtPetioleLaminaBoundary, " ", "") == "") { cellAtPetioleLaminaBoundary = "NULL"; }; else { cellAtPetioleLaminaBoundary = parseFloat(cellAtPetioleLaminaBoundary); if (isNaN(cellAtPetioleLaminaBoundary)) { error_cellAtPetioleLaminaBoundary = "TRUE"; }; else if (cellAtPetioleLaminaBoundary != round(cellAtPetioleLaminaBoundary)) { error_cellAtPetioleLaminaBoundary = "TRUE"; }; };
		}	
	
	while (error_meanAngle == "TRUE")
		{
		error_meanAngle = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("The angle the leaf will be rotated to be vertical (averaged across all images of the project)\nshould be either missing or given as a numeric values in degrees.");
		Dialog.addString("Mean angle (°) the leaf should be rotated to be vertical (keep BLANK if drawn leaf outlines):",""); 
		Dialog.show();
		meanAngle = Dialog.getString();
		if (replace(meanAngle, " ", "") == "") { meanAngle = "NULL"; }; else { meanAngle = parseFloat(meanAngle); if (isNaN(meanAngle)) { error_meanAngle = "TRUE"; }; };
		}

	while (error_zlim == "TRUE")
		{
		error_zlim = "FALSE";
		check_zmini = "FALSE";
		check_zmaxi = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("The limits for growth should be either missing or given as two numeric values.");
		Dialog.addString("Enter minimum for growth (keep BLANK if unknown):", "");
		Dialog.addString("AND maximum for growth (keep BLANK if unknown):", "");
		Dialog.show();
		zmini = Dialog.getString();
		if (replace(zmini, " ", "") == "") { zmini = "NULL"; check_zmini = "TRUE"; }; else { zmini = parseFloat(zmini); if (isNaN(zmini)) { error_zlim = "TRUE"; }; };
		zmaxi = Dialog.getString();
		if (replace(zmaxi, " ", "") == "") { zmaxi = "NULL"; check_zmaxi = "TRUE"; }; else { zmaxi = parseFloat(zmaxi); if (isNaN(zmaxi)) { error_zlim = "TRUE"; }; };
		if (check_zmini != check_zmaxi) { error_zlim = "TRUE"; };
		}
	if (zmini == parseFloat(zmini)) { if (zmini > zmaxi) { zmini_temp = zmini; zmini = zmaxi; zmaxi = zmini_temp; }; };
	
	while (error_anisothreshold == "TRUE")
		{
		error_anisothreshold = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("The anisotropy threshold should lie between 0 (low anisotropy is shown) and 1 (only the highest anisotropy is plotted).");
		Dialog.addNumber("Anisotropy threshold (0 - 1):", 0.05);
		Dialog.show();
		anisothreshold = Dialog.getNumber();
		if (anisothreshold != parseFloat(anisothreshold)) { error_anisothreshold = "TRUE"; };
		else if (anisothreshold < 0 || anisothreshold > 1) { error_anisothreshold = "TRUE"; };
		}
	
	while (error_anisolwd == "TRUE")
		{
		error_anisolwd = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("The factor for thickness of anisotropy lines should be either missing or a strictly positive value.");
		Dialog.addString("Positive factor for thickness of anisotropy lines (keep BLANK to let the software decide):","");
		Dialog.show();
		anisolwd = Dialog.getString();
		if (replace(anisolwd, " ", "") == "") { anisolwd = "NULL"; }; else { anisolwd = parseFloat(anisolwd); if (isNaN(anisolwd)) { error_anisolwd = "TRUE"; }; };
		}
	

	// Open the dialog box of the parameters specific to the kriging estimation
	
	Dialog.create("Choose parameters for the kriging estimation");
	Dialog.addMessage("####################################  KRIGING  ####################################");
	Dialog.addNumber("Grid density of the predicted surface (10 - 1000):", 100);
	Dialog.addNumber("Degree of the polynomial surface (2 - 6):", 3);
	Dialog.addNumber("Range of the exponential covariance function (> 0):", 0.001);
	Dialog.addCheckbox("Perform an additional kriging prediction over the whole leaf surface", false);
	Dialog.addMessage("###################################  CONTOURS  ###################################");	
	Dialog.addMessage("Enter the minimum, maximum and interval for contours, OR keep BLANK to let the software decide.\nTo plot a single contour, enter the same value for the minimum and the maximum, and set interval to zero.\nIn all cases, interval should be inferior or equal to maximum minus minimum.");
	Dialog.addString("Minimal growth value for contours:","");
	Dialog.addString("Maximal growth value for contours:","");
	Dialog.addString("Interval for contours:","");
	Dialog.addMessage("##################################  RESIDUALS  ##################################");	
	Dialog.addString("Enter minimum for residuals (keep BLANK if unknown):", "");
	Dialog.addString("AND maximum for residuals (keep BLANK if unknown):", "");
	Dialog.show();


	// Get the values back and transform them to match R script's requirements

	error_npred = "FALSE";
	error_degree = "FALSE";
	error_range = "FALSE";
	error_contours = "FALSE";
	check_cmini = "FALSE";
	check_cmaxi = "FALSE";
	check_cint = "FALSE";
	error_Reslim = "FALSE";
	check_Resmini = "FALSE";
	check_Resmaxi = "FALSE";

	npred = Dialog.getNumber();
	if (npred != parseFloat(npred)) { error_npred = "TRUE"; };
	else if (npred < 10 || npred > 1000 || npred != round(npred)) { error_npred = "TRUE"; };
	degree = Dialog.getNumber();
	if (degree != parseFloat(degree)) { error_degree = "TRUE"; };
	else if (degree < 2 || degree > 6 || degree != round(degree)) { error_degree = "TRUE"; };
	range = Dialog.getNumber();
	if (range != parseFloat(range)) { error_range = "TRUE"; };
	else if (range <= 0) { error_range = "TRUE"; };
	leafShapeKriging = Dialog.getCheckbox();
	if (leafShapeKriging == 1) { leafShapeKriging = "TRUE"; }; else { leafShapeKriging = "FALSE"; };
	cmini = Dialog.getString();
	if (replace(cmini, " ", "") == "") { cmini = "NULL"; check_cmini = "TRUE"; }; else { cmini = parseFloat(cmini); if (isNaN(cmini)) { error_contours = "TRUE"; }; };
	cmaxi = Dialog.getString();
	if (replace(cmaxi, " ", "") == "") { cmaxi = "NULL"; check_cmaxi = "TRUE"; }; else { cmaxi = parseFloat(cmaxi); if (isNaN(cmaxi)) { error_contours = "TRUE"; }; };
	cint = Dialog.getString();
	if (replace(cint, " ", "") == "") { cint = "NULL"; check_cint = "TRUE"; }; else { cint = parseFloat(cint); if (isNaN(cint)) { error_contours = "TRUE"; }; };
	if ((check_cmini != check_cmaxi) || (check_cmini != check_cint)) { error_contours = "TRUE"; };
	if (check_cmini == "FALSE" && check_cmaxi == "FALSE" && check_cint == "FALSE" && error_contours == "FALSE") { if (cint > (cmaxi - cmini) || cint < 0 || (cint == 0 && cmaxi != cmini)) { error_contours = "TRUE"; }; };
	Resmini = Dialog.getString();
	if (replace(Resmini, " ", "") == "") { Resmini = "NULL"; check_Resmini = "TRUE"; }; else { Resmini = parseFloat(Resmini); if (isNaN(Resmini)) { error_Reslim = "TRUE"; }; };
	Resmaxi = Dialog.getString();
	if (replace(Resmaxi, " ", "") == "") { Resmaxi = "NULL"; check_Resmaxi = "TRUE"; }; else { Resmaxi = parseFloat(Resmaxi); if (isNaN(Resmaxi)) { error_Reslim = "TRUE"; }; };
	if (check_Resmini != check_Resmaxi) { error_Reslim = "TRUE"; };


	// Check potential errors

	while (error_npred == "TRUE")
		{
		error_npred = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("Grid density for surface prediction should be an integer between 10 and 1000.");
		Dialog.addNumber("Grid density of the predicted surface (10 - 1000):", 100);
		Dialog.show();
		npred = Dialog.getNumber();
		if (npred != parseFloat(npred)) { error_npred = "TRUE"; };
		else if (npred < 10 || npred > 1000 || npred != round(npred)) { error_npred = "TRUE"; };
		}

	while (error_degree == "TRUE")
		{
		error_degree = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("The degree of the fitted polynomial surface should be an integer between 2 and 6.");
		Dialog.addNumber("Degree of the polynomial surface (2 - 6):", 3);
		Dialog.show();
		degree = Dialog.getNumber();
		if (degree != parseFloat(degree)) { error_degree = "TRUE"; };
		else if (degree < 2 || degree > 6 || degree != round(degree)) { error_degree = "TRUE"; };
		}

	while (error_range == "TRUE")
		{
		error_range = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("The range parameter for the exponential covariance function should be a strictly positive number.");
		Dialog.addNumber("Range parameter for the exponential covariance function (> 0):", 0.001);
		Dialog.show();
		range = Dialog.getNumber();
		if (range != parseFloat(range)) { error_range = "TRUE"; };
		else if (range <= 0) { error_range = "TRUE"; };
		}

	while (error_contours == "TRUE")
		{
		error_contours = "FALSE";
		check_cmini = "FALSE";
		check_cmaxi = "FALSE";
		check_cint = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("The limits and interval for the contours should be either missing or given as three numeric values.");
		Dialog.addMessage("Enter the minimum, maximum and interval for contours, OR keep BLANK to let the software decide.\nTo plot a single contour, enter the same value for the minimum and the maximum, and set interval to zero.\nIn all cases, interval should be inferior or equal to maximum minus minimum.");
		Dialog.addString("Minimal growth value for contours:","");
		Dialog.addString("Maximal growth value for contours:","");
		Dialog.addString("Interval for contours:","");
		Dialog.show();
		cmini = Dialog.getString();
		if (replace(cmini, " ", "") == "") { cmini = "NULL"; check_cmini = "TRUE"; }; else { cmini = parseFloat(cmini); if (isNaN(cmini)) { error_contours = "TRUE"; }; };
		cmaxi = Dialog.getString();
		if (replace(cmaxi, " ", "") == "") { cmaxi = "NULL"; check_cmaxi = "TRUE"; }; else { cmaxi = parseFloat(cmaxi); if (isNaN(cmaxi)) { error_contours = "TRUE"; }; };
		cint = Dialog.getString();
		if (replace(cint, " ", "") == "") { cint = "NULL"; check_cint = "TRUE"; }; else { cint = parseFloat(cint); if (isNaN(cint)) { error_contours = "TRUE"; }; };
		if (check_cmini != check_cmaxi || check_cmini != check_cint) { error_contours = "TRUE"; };
		if (check_cmini == "FALSE" && check_cmaxi == "FALSE" && check_cint == "FALSE" && error_contours == "FALSE") { if (cint > (cmaxi - cmini) || cint < 0 || (cint == 0 && cmaxi != cmini)) { error_contours = "TRUE"; }; };
		}
	if (cmini == parseFloat(cmini)) { if (cmini > cmaxi) { cmini_temp = cmini; cmini = cmaxi; cmaxi = cmini_temp; }; };
	
	while (error_Reslim == "TRUE")
		{
		error_Reslim = "FALSE";
		check_Resmini = "FALSE";
		check_Resmaxi = "FALSE";
		Dialog.create("Error, please correct");
		Dialog.addMessage("The limits for growth should be either missing or given as two numeric values.");
		Dialog.addString("Enter minimum for growth (keep BLANK if unknown):", "");
		Dialog.addString("AND maximum for growth (keep BLANK if unknown):", "");
		Dialog.show();
		Resmini = Dialog.getString();
		if (replace(Resmini, " ", "") == "") { Resmini = "NULL"; check_Resmini = "TRUE"; }; else { Resmini = parseFloat(Resmini); if (isNaN(Resmini)) { error_Reslim = "TRUE"; }; };
		Resmaxi = Dialog.getString();
		if (replace(Resmaxi, " ", "") == "") { Resmaxi = "NULL"; check_Resmaxi = "TRUE"; }; else { Resmaxi = parseFloat(Resmaxi); if (isNaN(Resmaxi)) { error_Reslim = "TRUE"; }; };
		if (check_Resmini != check_Resmaxi) { error_Reslim = "TRUE"; };
		}
	if (Resmini == parseFloat(Resmini)) { if (Resmini > Resmaxi) { Resmini_temp = Resmini; Resmini = Resmaxi; Resmaxi = Resmini_temp; }; };
	

	// Save parameters in a txt file

	File.delete("D:\\Parameters.txt")
	f = File.open("D:\\Parameters.txt");
	print(f, projDir);
	print(f, csvFile);
	print(f, meanAngle);
	print(f, alignToPetioleLaminaBoundary);
	print(f, cellAtPetioleLaminaBoundary);
	print(f, leafShape);
	print(f, before);
	print(f, kgrowth);
	print(f, black);
	print(f, ymini);
	print(f, ymaxi);
	print(f, scaleBar);
	print(f, tick);
	print(f, Percent);
	print(f, roundzlim);
	print(f, zmini);
	print(f, zmaxi);
	print(f, fixmin);
	print(f, fixmax);
	print(f, colorPaletteOfGFtbox);
	print(f, growthScale);
	print(f, drawTicks);
	print(f, txtlegend);
	print(f, anisotropy);
	print(f, anisothreshold);
	print(f, anisolwd);
	print(f, anisolwdconstant);
	print(f, fitLast);
	print(f, npred);
	print(f, degree);
	print(f, range);
	print(f, cmini);
	print(f, cmaxi);
	print(f, cint);
	print(f, leafShapeKriging);
	print(f, Resmini);
	print(f, Resmaxi);
	File.close(f);


/// Get the grahical output

	// Delete putative old files (just in case they were not deleted properly before)
	File.delete("D:\\count_img.txt");
	File.delete("D:\\" + nameOfRoutFile);
	File.delete("D:\\" + nameOfRScript);
	File.delete("D:\\Track_n_R.r");
	
	// Copy the R scripts to the 'D:\' drive (required because the javascript cannot read files in directory containing a space character)
	File.copy(pathOfScripts + nameOfRScript, "D:\\" + nameOfRScript);
	File.copy(pathOfScripts + "Track_n_R.r", "D:\\Track_n_R.r");

	// Run the java script that calls R (do not forget the "[" and "]" to allow space character in the path of the javascript)
	run("Run...", "run=" + "[" + pathOfScripts + nameOfJavaScript + "]");


/// Terminate macro

	// Check if the R script has finished properly
	endOfMacro = 0;
	while (endOfMacro == 0)
		{
		endOfMacro = File.exists("D:\\count_img.txt");
		if (endOfMacro == 0 && File.exists("D:\\" + nameOfRoutFile) == 1) 
			{
			wait(2000);
			linesRout = split(File.openAsString("D:\\" + nameOfRoutFile), lineseparator);
			if (linesRout.length > 0)
				{
				cellsRout = split(linesRout[linesRout.length - 1], cellseparator);
				if (cellsRout.length > 0)
					{
					if (cellsRout[0] == "Execution halted" || cellsRout[0] == "Exécution arrêtée")
						{
						macroAbort = "not aborted yet";
						while (macroAbort == "not aborted yet")
							{
							Dialog.create("Macro error");
							Dialog.addMessage("The macro could not finished properly.\n \nCheck the file 'D:\\" + nameOfRoutFile + "' for more details.\n \n Press 'Cancel' to abort the macro.");
							Dialog.show();
							}
						}
					}
				}
			}
		}

	// Get the count of processed images
	count_img = split(File.openAsString("D:\\count_img.txt"),"\n");
	count_img = count_img[0];

	// Delete unwanted files
	File.delete("D:\\count_img.txt");
	File.delete("D:\\Parameters.txt");
	File.delete("D:\\ImageList.txt");
	File.delete("D:\\" + nameOfRoutFile);
	File.delete("D:\\" + nameOfRScript);
	File.delete("D:\\Track_n_R.r");

	// Close Log
	if (isOpen("Log"))
		{
		selectWindow("Log");
     		run('Close');
		} 

	// Confirm to user
	Dialog.create("End of macro");
	if (count_img == 1) { display_count = count_img + " image has "; } else { display_count = count_img + " images have "; };
	Dialog.addMessage("*** FINISHED ***\n \n" + display_count + "been generated in\n" + projDir + "\Graphical Outputs");
	Dialog.show();
